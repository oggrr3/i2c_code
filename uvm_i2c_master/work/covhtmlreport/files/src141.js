var g_data = {"name":"../rtl/i2c_controller.v","src":"module i2c_controller\n    (\n        input               core_clk,\n        input               i2c_clk,\n        input               rst_n,\n        input               enable,\n        input  [7:0]        slave_address,\n        input  [7:0]        data_in,\n        input               repeated_start_cond,\n        // input               scl_in,\n        // input               sda_in,\n        // output              sda_out,\n        // output              scl_out,\n\n        inout               sda,\n        inout               scl,\n\n        // fifo enable\n        output reg          fifo_tx_enable,\n        output reg          fifo_rx_enable,\n\n        // converter enable\n        output reg          converter_enable\n    );\n    \n    localparam  IDLE          = 0;\n    localparam  START         = 1;\n    localparam  WRITE_ADDRESS = 2; \n    localparam  ADDRESS_ACK   = 3;\n    localparam  WRITE_DATA    = 4;\n    localparam  WRITE_ACK     = 5;\n    localparam  READ_DATA     = 6;\n    localparam  READ_ACK      = 7;\n    localparam  STOP          = 8;\n\n    reg [2:0]   counter;\n    reg [2:0]   ack_counter1;\n    reg [2:0]   ack_counter2;\n    reg [7:0]   saved_addr;\n    reg [7:0]   saved_data;\n    reg [3:0]   current_state;\n    reg [3:0]   next_state;\n    reg         scl_enable;\n    reg         sda_enable;\n    reg         sda_o;\n    wire        rw;\n    reg         tx_check;\n    reg         rx_check;\n\n    assign scl = (scl_enable == 1) ? i2c_clk : 1;\n    assign sda = (sda_enable == 1) ? sda_o   : 'bz;\n    // assign sda = (sda_o == 0) ? sda_o   : 'bz;\n    assign rw = slave_address[0]; \n\n    pullup(sda);\n    // State register logic\n    always @(posedge i2c_clk, negedge rst_n) begin\n        if (~rst_n) \n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Counter logic\n    always @(posedge i2c_clk, negedge rst_n) begin\n        if (~rst_n) begin\n            counter             <= 7;\n        end\n        else begin\n            if ((current_state == START) || (current_state == ADDRESS_ACK) || (current_state == WRITE_ACK) || (current_state == READ_ACK))\n                counter         <= 7;\n            if ((current_state == WRITE_ADDRESS) || (current_state == WRITE_DATA) || (current_state == READ_DATA))\n                counter         <= counter - 1;\n        end\n    end \n\n    // ACK counter logci\n    always @(posedge core_clk, negedge rst_n) begin\n        if(~rst_n) begin\n            ack_counter1        <= 0;\n            ack_counter2        <= 0;\n        end\n        else begin\n            if ((current_state == WRITE_ACK) || (current_state == READ_ACK)) begin\n                ack_counter1        <= ack_counter1 + 1;\n                if (ack_counter1 == 5)\n                    ack_counter1 <= 0;\n            end\n            else\n                ack_counter1    <= 0;\n            if ((current_state == WRITE_DATA) || (current_state == READ_DATA)) begin\n                ack_counter2        <= ack_counter2 + 1;\n                if (ack_counter2 == 5)\n                    ack_counter2 <= 0;\n            end\n            else    \n                ack_counter2    <= 0;\n        end\n    end\n\n    // Next state combinational logic\n    always @(posedge core_clk, negedge rst_n) begin\n        if (!rst_n)\n            next_state <= IDLE;\n        else begin\n            case (current_state)\n                IDLE: begin\n                    if (enable) begin \n                        next_state <= START;\n                    end\n                    else        next_state  <= IDLE;\n                end\n                //-----------------------------------------------------\n                \n                START:          next_state  <= WRITE_ADDRESS;\n                //-----------------------------------------------------\n\n                WRITE_ADDRESS: begin\n                    if (counter == 0) begin\n                                next_state  <= ADDRESS_ACK;\n                    end\n                end\n                //-----------------------------------------------------\n            \n                ADDRESS_ACK: begin\n                    if (sda == 0) begin\n                        // Sda_in <= 0 -> ack\n                        if (rw == 0) \n                                next_state  <= WRITE_DATA;\n                        else    next_state  <= READ_DATA;\n                    end\n                    else\n                        // sda_in <= 1 -> nack\n                        next_state <= STOP;\n                end\n                //-----------------------------------------------------\n\n                WRITE_DATA: begin\n                    if (counter == 0) begin\n                                next_state  <= WRITE_ACK;\n                    end\n                end\n                //-----------------------------------------------------\n\n                WRITE_ACK: begin\n                    if (sda == 0) begin\n                        if (enable == 0) begin\n                                    next_state <= STOP;\n                        end\n                        //else if (enable == 1) begin\n                        else begin                                             //   Modify above number to run code coverage\n                            if (repeated_start_cond == 0)   \n                                    next_state <= WRITE_DATA;\n                            else\n                                    next_state <= START;\n                        end\n                    end\n                    else begin\n                        next_state <= STOP;\n                    end\n                end\n                \n                //-----------------------------------------------------\n\n                READ_DATA: begin\n                    if (counter == 0) begin\n                            next_state <= READ_ACK;\n                    end\n                end\n                //-----------------------------------------------------\n\n                READ_ACK: begin\n                    if (enable == 0) begin\n                                next_state  <= STOP;\n                    end\n                    //else if (enable <= 1) begin\n                    else    begin                                   //  Modify from above line to run code coverage\n                        if (repeated_start_cond == 0)   \n                                next_state  <= READ_DATA;\n                        else\n                                next_state  <= START;\n                    end\n                end\n                //-----------------------------------------------------\n                default:        next_state  <= IDLE;\n            endcase\n        end\n    end\n    always @(posedge core_clk, negedge rst_n) begin\n        if (!rst_n) begin\n            scl_enable                  <= 0;\n            sda_enable                  <= 0;\n            sda_o                       <= 1;\n            fifo_rx_enable              <= 0;\n            fifo_tx_enable              <= 0;\n            converter_enable            <= 0;\n            rx_check                    <= 0;\n            tx_check                    <= 0;\n        end\n        else begin\n            if (fifo_tx_enable == 1) begin\n                fifo_tx_enable          <= 0;   \n            end\n            case(current_state)\n                IDLE: begin\n                    saved_addr          <= {slave_address}; \n                    scl_enable          <= 0;\n                    sda_o               <= 1;\n                    sda_enable          <= 1;\n                end\n                //-----------------------------------------------------\n                START: begin\n                    sda_o               <= 0;\n                    scl_enable          <= 0;\n                    sda_enable          <= 1;\n                end\n                //-----------------------------------------------------\n                WRITE_ADDRESS: begin\n                    scl_enable          <= 1;\n                    sda_enable          <= 1;\n                    if (i2c_clk == 0) \n                        sda_o           <= saved_addr[counter];\n                end\n                //-----------------------------------------------------\n                ADDRESS_ACK: begin\n                    scl_enable          <= 1;  \n                    saved_data          <= {data_in}; \n                    if (i2c_clk == 0) begin\n                        sda_o           <= 1;      \n                        sda_enable      <= 0;   \n                    end\n                end\n                //-----------------------------------------------------\n                WRITE_DATA: begin\n                    scl_enable          <= 1;\n                    tx_check            <= 0;\n                    if (ack_counter2 == 3)\n                        sda_enable      <= 1;\n\n                    if (i2c_clk == 0) begin\n                        sda_o           <= saved_data[counter];\n                    end\n                end\n                //-----------------------------------------------------\n\n                WRITE_ACK: begin\n                    scl_enable          <= 1;\n                    saved_data          <= {data_in};\n                    if (ack_counter1 == 3)\n                        sda_enable      <= 0;  \n                    if(sda == 0) begin\n                        fifo_tx_enable  <= 1;\n                        tx_check        <= 1;\n                    end\n                    if (tx_check == 1) begin\n                        fifo_tx_enable  <= 0;\n                    end\n                    if (i2c_clk == 0) begin\n                        sda_o           <= 0;\n                    end\n                end\n                //-----------------------------------------------------\n\n                READ_DATA: begin\n                    // sda_o               <= 1;\n                    scl_enable          <= 1;\n                    converter_enable    <= 1;\n                    rx_check            <= 0;\n                    if (ack_counter2 == 3)\n                        sda_enable      <= 0;\n                end\n                //-----------------------------------------------------\n\n                READ_ACK: begin\n                    scl_enable          <= 1;\n                    converter_enable    <= 0;\n                    fifo_rx_enable      <= 1;\n                    rx_check            <= 1;\n                    if (rx_check == 1)\n                        fifo_rx_enable  <= 0;\n                    if (i2c_clk == 0)\n                        sda_o           <= 0;\n                    if (ack_counter1 == 3)\n                        sda_enable      <= 1;  \n                end\n                //-----------------------------------------------------\n\n                STOP: begin\n                    sda_enable          <= 1;\n                    sda_o               <= 0;\n                    scl_enable          <= 1;\n                end\n                //-----------------------------------------------------\n                default: begin\n                    sda_o               <= 1;\n                    scl_enable          <= 0;\n                    sda_enable          <= 1;\n                end\n            endcase\n        end\n    end\nendmodule","lang":"verilog"};
processSrcData(g_data);
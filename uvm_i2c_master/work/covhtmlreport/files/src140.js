var g_data = {"name":"../rtl/apb_slave.v","src":"module apb\n    (\n	    input               PCLK,           // Clock\n		input               PRESETn,        // Active-low reset\n		input               PSELx,          // Select\n		input               PWRITE,         // Direction: \n                                                // 1 -> write\n                                                // 0 -> read\n		input               PENABLE,        // Enable\n		input       [7:0]   PADDR,          // APB address bus, 8 bits\n		input       [7:0]   PWDATA,         // Write data\n        input       [7:0]   status_reg,      \n        input       [7:0]   receive_reg,\n\n		output              PREADY,         // Ready\n                                            // Slave can complete the transfer at next PCLK posedge\n        output reg  [7:0]   PRDATA,\n        output reg  [7:0]   transmit_reg, \n        output reg  [7:0]   command_reg,\n        output reg  [7:0]   prescale_reg,\n        output reg  [7:0]   address_reg\n	);\n\n    reg                     TX_empty;\n    reg                     TX_full;\n    reg                     RX_full;\n    reg                     RX_empty;\n    // reg [2:0]               reg_map;\n\n\n    // Input status\n    always @* begin\n        TX_full             = status_reg[7];\n        TX_empty            = status_reg[6];\n        RX_full             = status_reg[5];\n        RX_empty            = status_reg[4];\n    end\n\n    // always @(posedge PCLK, negedge PRESETn) begin\n    //     if (!PRESETn)\n    //         reg_map <= 3'b0;\n    //     else\n    //         reg_map <= PADDR[7:5];\n    // end\n    \n    // READY\n    assign PREADY = ((PENABLE == 1'b1) & (PSELx == 1'b1)) ? 1'b1 : 1'b0;\n    \n    // DATA READ FROM FIFO\n    // assign PRDATA = ((RX_empty == 0) & (PENABLE == 1'b1) & (PWRITE == 1'b0) & (PSELx == 1'b1)) ? receive_reg : 8'b0;\n\n    \n\n    always @(posedge PCLK, negedge PRESETn) begin\n        if (!PRESETn) begin\n            command_reg                 <= 8'b00000000;\n            address_reg                 <= 8'b0;\n            prescale_reg                <= 8'b0;\n        end\n        else begin \n            case (PADDR)\n                // Write to Prescale register\n                1: begin\n                    if ((PWRITE == 1) && (PSELx == 1) && (PENABLE == 1))\n                        prescale_reg    <= PWDATA;\n                end\n\n                // Write to slave address\n                2: begin\n                    if ((PWRITE == 1) && (PSELx == 1) && (PENABLE == 1))\n                        address_reg     <= PWDATA;\n                end\n\n                // Read from status register\n                3: begin\n                    if ((PWRITE == 0) && (PSELx == 1) && (PENABLE == 1))\n                        PRDATA          <= status_reg;\n                end\n\n                // Write to transmit register\n                4: begin\n                    if ((PWRITE == 1) && (PSELx == 1) && (PENABLE == 1)) begin\n                        transmit_reg    <= PWDATA;\n                        command_reg     <= 11010000;\n                    end\n                    if (PSELx == 0)\n                        command_reg     <= 10010000;\n                end\n\n                // Read from receive register\n                5: begin\n                    if (PSELx == 0)\n                        command_reg     <= 10010000;\n                    //else if ((PWRITE == 0) && (PSELx == 1) && (PENABLE == 1)) begin\n                    else if ((PWRITE == 0) && (PENABLE == 1)) begin                 //  Modify to run code coverage\n                        PRDATA          <= receive_reg;\n                        command_reg     <= 10110000;\n                    end\n                end\n                \n                // Write to Command regisger\n                6: begin\n                    if ((PWRITE == 1) && (PSELx == 1) && (PENABLE == 1))\n                        command_reg     <= PWDATA;\n                end\n            endcase            \n        end\n    end\nendmodule","lang":"verilog"};
processSrcData(g_data);
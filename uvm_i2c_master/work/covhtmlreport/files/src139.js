var g_data = {"name":"../rtl/fifo.v","src":"module FIFO_memory \n#(parameter data_size = 8, parameter address_size = 3)\n    (\n        input   [data_size-1:0]     write_data,\n        input   [address_size-1:0]  write_address,\n        input   [address_size-1:0]  read_address,\n        input                       write_enable,\n        input                       write_full,\n        input                       write_clk,\n        output  [data_size-1:0]     read_data\n    );\n    \n    localparam  FIFO_depth = 1<<address_size;\n    reg [data_size-1:0] mem [0:FIFO_depth-1];\n    \n    // read the data at the output of memory\n    assign read_data = mem[read_address];\n    //Write a data on rising edge of write clock at specific address location \n    \n    always @(posedge write_clk) begin\n        if (write_enable && !write_full)\n            mem[write_address] <= write_data;\n    end\nendmodule\n\nmodule write_pointer_full #(parameter address_size = 4)\n    (\n        input                           write_reset_n,\n        input                           write_clk,\n        input                           write_enable,\n        input       [address_size :0]   write_to_read_pointer,\n        output reg  [address_size-1:0]  write_address,\n        output reg  [address_size :0]   write_pointer,\n        output reg                      write_full\n    );\n    reg [address_size:0] write_gray_next;\n    reg [address_size:0] write_binary_next;\n    reg [address_size:0] write_binary;\n\n    // Binary pointers to the memory buffer\n    always@* begin\n        write_address = write_binary[address_size-1:0];\n        write_binary_next = write_binary + (write_enable & ~write_full); \n        write_gray_next = (write_binary_next>>1) ^ write_binary_next;\n    end\n    // let us use the gray pointers\n    always @(posedge write_clk , negedge write_reset_n) begin\n        if (~write_reset_n)\n            {write_binary, write_pointer} <= 0;\n        else\n            {write_binary, write_pointer} <= {write_binary_next, write_gray_next};\n    end\n    always @(posedge write_clk , negedge write_reset_n) begin\n        if (!write_reset_n) \n            write_full <= 1'b0;\n        else\n            write_full <= (write_gray_next=={~write_to_read_pointer[address_size:address_size-1], write_to_read_pointer[address_size-2:0]});\n    end\nendmodule\n\nmodule read_pointer_empty #(parameter address_size = 3)\n    (\n        input                           read_reset_n,\n        input                           read_enable,\n        input                           read_clk,\n        input       [address_size :0]   read_to_write_pointer,\n        output reg  [address_size-1:0]  read_address,\n        output reg  [address_size :0]   read_pointer,\n        output reg                      read_empty \n    );\n\n    reg [address_size:0] read_binary;\n    reg [address_size:0] read_gray_next;\n    reg [address_size:0] read_binary_next;\n    \n\n    always@*\n        begin\n            read_address = read_binary[address_size-1:0];\n            read_binary_next = read_binary + (read_enable & ~read_empty); \n            read_gray_next = (read_binary_next>>1) ^ read_binary_next;\n            \n    end\n\n    always @(posedge read_clk , negedge read_reset_n) begin\n        if (~read_reset_n)\n            {read_binary, read_pointer} <= 0;\n        else\n            {read_binary, read_pointer} <= {read_binary_next, read_gray_next};\n    end\n\n    // FIFO empty logic\n    always @(posedge read_clk , negedge read_reset_n) begin\n        if (~read_reset_n)\n            read_empty <= 1'b1;\n        else\n            read_empty <= (read_gray_next == read_to_write_pointer);\n    end\nendmodule\n\nmodule sync_read_to_write #(parameter address_size = 3)\n    (\n    input                           write_reset_n,\n    input                           write_clk,\n    input       [address_size:0]    read_pointer,\n    output reg  [address_size:0]    write_to_read_pointer\n    );\n\n    reg [address_size:0] tmp1_read_pointer;\n    //Multi-flop synchronizer logic for passing the control signals and pointers\n    always @(posedge write_clk , negedge write_reset_n) begin\n        if (~write_reset_n)\n            {write_to_read_pointer,tmp1_read_pointer} <= 0;\n        else\n            {write_to_read_pointer,tmp1_read_pointer} <= {tmp1_read_pointer,read_pointer};\n    end\nendmodule\n\nmodule sync_write_to_read #(parameter address_size = 3)\n    (\n        input       [address_size:0]    write_pointer,\n        input                           read_reset_n,\n        input                           read_clk,\n        output reg  [address_size:0]    read_to_write_pointer\n    );\n\n    reg [address_size:0] tmp1_write_pointer;\n    \n    always @(posedge read_clk , negedge read_reset_n) begin\n        if (~read_reset_n)\n            {read_to_write_pointer,tmp1_write_pointer} <= 0;\n        else\n            {read_to_write_pointer,tmp1_write_pointer} <= {tmp1_write_pointer,write_pointer};\n    end\nendmodule\n\nmodule FIFO_top \n#(parameter data_size = 8,parameter address_size = 3)\n(\n    input [data_size-1:0]   write_data,\n    input                   write_enable,\n    input                   write_clk,\n    input                   write_reset_n,\n\n    input                   read_enable,\n    input                   read_clk,\n    input                   read_reset_n,\n\n    output [data_size-1:0]  read_data,\n    output                  write_full,\n    output                  read_empty\n);\n\nwire [address_size-1:0]     write_address;\nwire [address_size-1:0]     read_address;\nwire [address_size:0]       write_pointer;\nwire [address_size:0]       read_pointer;\nwire [address_size:0]       write_to_read_pointer;\nwire [address_size:0]       read_to_write_pointer;\n\nFIFO_memory #(data_size, address_size) fifomem\n(\n    .write_clk              (write_clk),\n    .write_enable           (write_enable),\n    .write_data             (write_data),\n    .write_address          (write_address),\n    .read_data              (read_data),\n    .read_address           (read_address),\n    .write_full             (write_full)\n);\n\nread_pointer_empty #(address_size) read_pointer_empty\n(\n    .read_clk               (read_clk),\n    .read_reset_n           (read_reset_n),\n    .read_enable            (read_enable) ,\n    .read_address           (read_address),\n    .read_pointer           (read_pointer),\n    .read_empty             (read_empty),\n    .read_to_write_pointer  (read_to_write_pointer)\n);\n\nwrite_pointer_full #(address_size) write_pointer_full\n(\n    .write_clk              (write_clk),\n    .write_reset_n          (write_reset_n),\n    .write_enable           (write_enable),\n    .write_address          (write_address),\n    .write_pointer          (write_pointer),\n    .write_full             (write_full),\n    .write_to_read_pointer  (write_to_read_pointer)\n);\n\nsync_read_to_write sync_read_to_write\n(\n    .write_clk              (write_clk),\n    .write_reset_n          (write_reset_n),\n    .read_pointer           (read_pointer),\n    .write_to_read_pointer  (write_to_read_pointer)\n);\n\nsync_write_to_read sync_write_to_read\n(\n    .read_clk               (read_clk),\n    .read_reset_n           (read_reset_n),\n    .write_pointer          (write_pointer),\n    .read_to_write_pointer  (read_to_write_pointer)\n);\nendmodule","lang":"verilog"};
processSrcData(g_data);